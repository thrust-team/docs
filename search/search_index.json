{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Index \u00b6 This website contains the knowledge acquired during the research and development of a hybrid rocket by the University of Padua students' team. Documentation Technology \u00b6 These pages are written in CommonMark, and thanks to MkDocs they support also LaTeX-style math formulas. \\[ c^* = \\frac{I_sg_0}{C_F} = \\frac{c}{C_F} = \\frac{\\sqrt{kRT_1}}{k\\sqrt{(\\frac{2}{k+1})^{\\frac{k+1}{k-1}}}} \\] Documentation Layout \u00b6 The knowledge will be divided based on the field of application. - subsystems - propulsion - tank - lines - valve - injection - combustion chamber - nozzle - recovery - on board electronics - structures - aerodynamics - payload - mission phases - mission plan - preliminary design - test campaign - critical design - launch campaign - competition","title":"Index"},{"location":"#index","text":"This website contains the knowledge acquired during the research and development of a hybrid rocket by the University of Padua students' team.","title":"Index"},{"location":"#documentation-technology","text":"These pages are written in CommonMark, and thanks to MkDocs they support also LaTeX-style math formulas. \\[ c^* = \\frac{I_sg_0}{C_F} = \\frac{c}{C_F} = \\frac{\\sqrt{kRT_1}}{k\\sqrt{(\\frac{2}{k+1})^{\\frac{k+1}{k-1}}}} \\]","title":"Documentation Technology"},{"location":"#documentation-layout","text":"The knowledge will be divided based on the field of application. - subsystems - propulsion - tank - lines - valve - injection - combustion chamber - nozzle - recovery - on board electronics - structures - aerodynamics - payload - mission phases - mission plan - preliminary design - test campaign - critical design - launch campaign - competition","title":"Documentation Layout"},{"location":"code/general/","text":"General Coding Practices \u00b6 THE PURPOSE OF COMPUTING IS INSIGHT, NOT NUMBERS Richard Hamming, The Art Of Computing 1987, Ch. N+1 Overview \u00b6 The goal of every script is ether: Function of a library to be used by many scripts Script that relates many functions and values Input/Output for information files Showing the results in graphical or tabular form If your script does not do any of the above, think about what you need it for, and more importantly about what others will need it for. Units \u00b6 All units must be in the International Standard.","title":"General Coding Practices"},{"location":"code/general/#general-coding-practices","text":"THE PURPOSE OF COMPUTING IS INSIGHT, NOT NUMBERS Richard Hamming, The Art Of Computing 1987, Ch. N+1","title":"General Coding Practices"},{"location":"code/general/#overview","text":"The goal of every script is ether: Function of a library to be used by many scripts Script that relates many functions and values Input/Output for information files Showing the results in graphical or tabular form If your script does not do any of the above, think about what you need it for, and more importantly about what others will need it for.","title":"Overview"},{"location":"code/general/#units","text":"All units must be in the International Standard.","title":"Units"},{"location":"code/matlab/","text":"Matlab Standards \u00b6 Header \u00b6 All MatLab scripts shall start with a header like so %% Script title % Author(s) and date % % What the script does % Briefly describe inputs and outputs Requirements interface steup \u00b6 In the code folder, you will find three scripts that you will need to add to the start of your script in order to make it work with the requirements and results folder req . SETUP.m SAVE_NUMBER_TO_TXT.m LOAD_CONSTANTS.m Setup file SETUP.m \u00b6 This file will link your script to the shared requirements folder of the launcher to be designed. PATH_REQ_FOLDER should be set to the /req/ folder address in your system PATH_CONSTANTS should be set to the /const/ folder address in your system The functions are READ_REQ(REQ_NAME) : Assigns a requirement value to a variable SAVE_REQ(REQ_NAME, VALUE) : Saves a value to the requirement file Constants file LOAD_CONSTANTS.m \u00b6 When called into your script it will load all physical constants shared by the team. How to use the interface \u00b6 Importing values \u00b6 Every script, after the header, shall import the values it needs from the project (which must be either constants or requirements set by the team or generated by some other script) as follows: % Importing requirements as constants SOME_REQUIREMENT_VARIABLE = READ_REQ ( 'SOME_REQUIREMENT_VARIABLE' ); TARGET_ALTITUDE = READ_REQ ( 'SFR_MISSION_TARGET_ALTITUDE' ); TARGET_MASS = READ_REQ ( 'SFR_MISSION_TARGET_MASS' ); TARGET_ALTITUDE_MARGIN_OF_SAFETY = READ_REQ ( 'SFR_MISSION_ALTITUDE_MARGIN_OF_SAFETY' ); This style ensures that variables names are indicative and shared (can be easily copied and pasted from one script to another and shows visibly which inputs a script requires. (Optional) Renaming Values for Shorter Equations \u00b6 Values inside the script can be renamed x = SOME_REQUIREMENT_VARIABLE ; h = TARGET_ALTITUDE ; This allows to easily load the interface for a script already written without the requirements interface in mind, and without having to rename the variables inside the formulas. In general it is more common to write formulas with symbols instead of requirement names. Do the math \u00b6 Here the magic happens. Save results \u00b6 All results should be saved to a file, whether text (value) or image (plot), and not just kept in memory. To save values, the Requirement Interface is used as follows. First rename the variables to a meaningful name: TARGET_DELTA_V = v0 ; PROPELLANT_MASS_RATIO = mprop_mi ; Then save them to a text file, which will go inside the requirements folder. Always try to keep the variable name and filename equivalent for easier use in other scripts. SAVE_REQ ( 'SOME_REQUIREMENT_VARIABLE' , SOME_REQUIREMENT_VARIABLE ) SAVE_REQ ( 'SFR_MISSION_TARGET_DELTA_V' , TARGET_DELTA_V ); SAVE_REQ ( 'SFR_MISSION_TARGET_TOTAL_IMPULSE' , TARGET_TOTAL_IMPULSE ); Warning \u00b6 This last step overwrites files without asking. You must be sure the script does the right math before committing. Read the following 10 times: All scripts should create new requirements. No script should overwrite a requirement that was there before it.","title":"Matlab Standards"},{"location":"code/matlab/#matlab-standards","text":"","title":"Matlab Standards"},{"location":"code/matlab/#header","text":"All MatLab scripts shall start with a header like so %% Script title % Author(s) and date % % What the script does % Briefly describe inputs and outputs","title":"Header"},{"location":"code/matlab/#requirements-interface-steup","text":"In the code folder, you will find three scripts that you will need to add to the start of your script in order to make it work with the requirements and results folder req . SETUP.m SAVE_NUMBER_TO_TXT.m LOAD_CONSTANTS.m","title":"Requirements interface steup"},{"location":"code/matlab/#setup-file-setupm","text":"This file will link your script to the shared requirements folder of the launcher to be designed. PATH_REQ_FOLDER should be set to the /req/ folder address in your system PATH_CONSTANTS should be set to the /const/ folder address in your system The functions are READ_REQ(REQ_NAME) : Assigns a requirement value to a variable SAVE_REQ(REQ_NAME, VALUE) : Saves a value to the requirement file","title":"Setup file SETUP.m"},{"location":"code/matlab/#constants-file-load_constantsm","text":"When called into your script it will load all physical constants shared by the team.","title":"Constants file LOAD_CONSTANTS.m"},{"location":"code/matlab/#how-to-use-the-interface","text":"","title":"How to use the interface"},{"location":"code/matlab/#importing-values","text":"Every script, after the header, shall import the values it needs from the project (which must be either constants or requirements set by the team or generated by some other script) as follows: % Importing requirements as constants SOME_REQUIREMENT_VARIABLE = READ_REQ ( 'SOME_REQUIREMENT_VARIABLE' ); TARGET_ALTITUDE = READ_REQ ( 'SFR_MISSION_TARGET_ALTITUDE' ); TARGET_MASS = READ_REQ ( 'SFR_MISSION_TARGET_MASS' ); TARGET_ALTITUDE_MARGIN_OF_SAFETY = READ_REQ ( 'SFR_MISSION_ALTITUDE_MARGIN_OF_SAFETY' ); This style ensures that variables names are indicative and shared (can be easily copied and pasted from one script to another and shows visibly which inputs a script requires.","title":"Importing values"},{"location":"code/matlab/#optional-renaming-values-for-shorter-equations","text":"Values inside the script can be renamed x = SOME_REQUIREMENT_VARIABLE ; h = TARGET_ALTITUDE ; This allows to easily load the interface for a script already written without the requirements interface in mind, and without having to rename the variables inside the formulas. In general it is more common to write formulas with symbols instead of requirement names.","title":"(Optional) Renaming Values for Shorter Equations"},{"location":"code/matlab/#do-the-math","text":"Here the magic happens.","title":"Do the math"},{"location":"code/matlab/#save-results","text":"All results should be saved to a file, whether text (value) or image (plot), and not just kept in memory. To save values, the Requirement Interface is used as follows. First rename the variables to a meaningful name: TARGET_DELTA_V = v0 ; PROPELLANT_MASS_RATIO = mprop_mi ; Then save them to a text file, which will go inside the requirements folder. Always try to keep the variable name and filename equivalent for easier use in other scripts. SAVE_REQ ( 'SOME_REQUIREMENT_VARIABLE' , SOME_REQUIREMENT_VARIABLE ) SAVE_REQ ( 'SFR_MISSION_TARGET_DELTA_V' , TARGET_DELTA_V ); SAVE_REQ ( 'SFR_MISSION_TARGET_TOTAL_IMPULSE' , TARGET_TOTAL_IMPULSE );","title":"Save results"},{"location":"code/matlab/#warning","text":"This last step overwrites files without asking. You must be sure the script does the right math before committing. Read the following 10 times: All scripts should create new requirements. No script should overwrite a requirement that was there before it.","title":"Warning"},{"location":"propulsion/tank/tank-biphase/","text":"Biphase Model for Saturated Tank \u00b6 Alberto The tank holds a self pressurized oxidizer, which is in saturation condition between liquid and vapor. Oxidizer Extraction Model \u00b6 Suppose a tank is filled up to a certain point with liquid oxidizer and its vapor is saturated at a certain ambient temperature. Parameters \u00b6 The parameters of the tank before the extraction are: \\(V_T\\) Internal volume of the tank \\(m_O\\) Mass of oxidizer stored in the tank \\(T_0\\) Initial extraction temperature Other variables can thus be described, such as: \\(V_O\\) Volume occupied by liquid oxidizer \\(f\\) Ullage volume percentage The following solver needs as initial conditions only: \\(T_0\\) Starting saturation temperature \\(f\\) Vapor volume percentage (ullage) and the following data for the chosen oxidizer. Oxidizer Data \u00b6 Data for known properties of the oxidizer as a function of temperature are needed: \\(p_{Sat}(T)\\) Saturation pressure for a given temperature \\(\\rho_l(T)\\) Density of the saturated liquid for a given temperature \\(\\rho_v(T)\\) Density of the saturated vapor for a given temperature \\(s_l(T)\\) Specific entropy of the saturated liquid for a given temperature \\(s_v(T)\\) Specific entropy of the saturated vapor for a given temperature Extraction \u00b6 The physical quantities are regulated by the following expressions: \\[ \\begin{aligned} v_l(T) &= \\frac1{\\rho_l(T)} \\\\ v_v(T) &= \\frac1{\\rho_l(T)} \\\\ x(v, T) &= \\frac{v - v_l(T)}{v_v(T) - v_l(T)} \\\\ \\end{aligned} \\] The mapping of \\((x,T) \\to (s,v)\\) is given by: \\[ \\begin{aligned} s(x, T) &= (1 - x) \\cdot s_l(T) + x \\cdot s_v(T) \\\\ v(x, T) &= (1 - x) \\cdot v_l(T) + x \\cdot v_v(T) \\\\ \\end{aligned} \\] The goal is to find the inverse map \\[ (s,v) \\to (x,T) \\] since evaluating \\(s\\) and \\(v\\) for the mass extraction is trivial. The functions \\(s(x,T)\\) and \\(v(x,T)\\) can be differentiated with respect to \\(x\\) and \\(T\\) as: \\[ \\begin{aligned} dv = \\frac{\\partial v}{\\partial x}\\, dx + \\frac{\\partial v}{\\partial T}\\,dT \\\\ ds = \\frac{\\partial s}{\\partial x}\\, dx + \\frac{\\partial s}{\\partial T}\\,dT \\end{aligned} \\] which in matrix form becomes \\[ \\begin{Bmatrix} dv \\\\ ds \\end{Bmatrix} = \\begin{bmatrix} \\dfrac{\\partial v}{\\partial x} & \\dfrac{\\partial v}{\\partial T}\\\\ \\dfrac{\\partial s}{\\partial x}& \\dfrac{\\partial s}{\\partial T} \\end{bmatrix} \\begin{Bmatrix} dx \\\\ dT \\end{Bmatrix} \\] and inverting algebraically \\[ \\begin{Bmatrix} dx \\\\ dT \\end{Bmatrix} = \\begin{bmatrix} \\dfrac{\\partial v}{\\partial x} & \\dfrac{\\partial v}{\\partial T}\\\\ \\dfrac{\\partial s}{\\partial x}& \\dfrac{\\partial s}{\\partial T} \\end{bmatrix}^{-1} \\begin{Bmatrix} dv \\\\ ds \\end{Bmatrix} \\] The quantities sought after are then computed as: \\[ \\begin{Bmatrix} x(s,v) \\\\ T(s,v) \\end{Bmatrix} = \\begin{Bmatrix} x_0 \\\\ T_0 \\end{Bmatrix} + \\int_{(s_0,T_0)} [J]^{-1} \\begin{Bmatrix} dv \\\\ ds \\end{Bmatrix},\\quad \\text{until $x =1$} \\] Numerical solution \u00b6 Time constraints \u00b6 The extraction time \\(t_n\\) can be considered adimensional \\[ t_n = 1\\] therefore the \\(n\\) computation steps are \\[n = \\frac{t_n}{\\Delta t}\\] where \\(\\Delta t\\) is a reasonably low number (ex. \\(\\Delta t = 5\\cdot10^{-4}\\) ). Although the initial conditions are useful, some of them can be discarded by considering the problem adimensionalized with respect to the mass of oxidizer stored inside the tank. Initial conditions \u00b6 \\[ m_0 = 1 \\] Therefore the liquid mass is \\[ m_{l,0} = \\frac{m_0}{1 + f \\cdot \\frac{\\rho_{v,0}}{\\rho_{l,0}}} \\] And vapor mass is \\[ m_{v,0} = m_0 - m_{l,0}\\] The oxidizer liquid volume is simply \\[ V_{l,0} = \\frac{m_{l,0}}{\\rho_{l,0}} \\] which can be used to get the total volume \\[ V_0 = V_{l,0} \\cdot (1+f) \\] and the vapor volume \\[ V_{v,0} = V_0 - V_{l,0}.\\] The following are the initial conditions of the loop \\[ \\begin{aligned} T_0 &\\\\ p_0 &= p_{Sat}(T_0)\\\\ v_0 &= \\frac{V_0}{m_0} \\\\ x_0 &= x(v_0,T_0) \\\\ s_0 &= s(x_0, T_0) \\\\ S_0 &= m_0 \\cdot s_0 \\\\ \\dot{m}_0 &= \\frac{m_0}{t_n} \\end{aligned} \\] Mass extraction \u00b6 The mass that gets extracted at every computation step from the tank is computed as \\[ dm_i = \\dot{m}_i \\cdot dt \\] and the remaining mass inside the tank is thus: \\[ m_{i+1} = m_i - dm_i \\] Whether the extraction is done of liquid oxidizer or vapor oxidizer, the entropy \\(S\\) of the mass left in the tank is computed as: \\[ \\begin{cases} S_{i+1} = S_i - dm_i \\cdot s_l(T_i),& \\quad \\text{liquid extraction}\\\\ S_{i+1} = S_i - dm_i \\cdot s_v(T_i),& \\quad \\text{vapor extraction} \\end{cases} \\] And thus the specific entropy \\(s\\) and specific volume \\(v\\) are \\[ \\begin{aligned} s_{i+1} &= \\frac{S_{i+1}}{m_{i+1}} \\\\ v_{i+1} &= \\frac{V_0}{m_{i+1}} \\end{aligned} \\] Vapor Quality and Temperature Evaluation \u00b6 The next goal is to compute the variation of vapor quality \\(x\\) and temperature \\(T\\) given the variation in specific volume \\(v\\) and specific enthalpy \\(s\\) after th extraction. The problem is now finding the quantities inside the Jacobian matrix. The partial derivatives with respect to vapor quality \\(x\\) are immediate: \\[ \\begin{aligned} \\frac{\\partial v}{\\partial x} &= v_v(T) - v_l(T) \\\\ \\frac{\\partial s}{\\partial x} &= s_v(T) - s_l(T) \\end{aligned} \\] but the derivatives with respect to temperature \\(T\\) must be computed numerically, in this case with central finite difference: \\[ \\begin{aligned} \\frac{\\partial v}{\\partial T} &= \\frac1{2\\varepsilon} [v(x,T+\\varepsilon)-v(x,T-\\varepsilon)] \\\\ \\frac{\\partial s}{\\partial T} &= \\frac1{2\\varepsilon} [s(x,T+\\varepsilon)-s(x,T-\\varepsilon)] \\end{aligned} \\] Starting the evaluation from the current temperature \\(T_i\\) , the target temperature \\(T_{i+1}\\) will be reached with successive approssimation of a progressively changing temperature \\(T_j\\) until the residue \\(r\\) is under the desired tolerance: \\[ r = \\sqrt{\\frac{dT_j}{T_j}^2+\\frac{dx_j}{x_j}^2}\\leq \\text{tol} \\] The guesses for temperature \\(T_j\\) and vapor quality \\(x_j\\) are updated as: \\[ \\begin{aligned} T_{j+1} = T_j + dT_j \\\\ x_{j+1} = x_j + dx_j \\end{aligned} \\] until the final temperature \\(T_{i+1}\\) is the \\(n\\) -th guess temperature \\(T_j\\mid_{j=n}\\) . In summary: \\[ \\begin{aligned} T_{i+1} - T_{i} = \\sum_{\\substack{T_j=T_i \\\\ x_j = x_i}}^{r<tol} dT_j(x_j,T_j) \\\\ x_{i+1} - x_{i} = \\sum_{\\substack{T_j=T_i \\\\ x_j = x_i}}^{r<tol} dx_j(x_j,T_j) \\end{aligned} \\] where, using the formula for the inverse of a \\(2 \\times 2\\) matrix: \\[ \\begin{Bmatrix} dx_j \\\\ dT_j \\end{Bmatrix} = \\frac{1}{\\frac{\\partial v}{\\partial x}\\frac{\\partial s}{\\partial T} - \\frac{\\partial s}{\\partial x}\\frac{\\partial v}{\\partial T}} \\begin{bmatrix} \\frac{\\partial s}{\\partial x} & -\\frac{\\partial v}{\\partial T}\\\\ -\\frac{\\partial s}{\\partial x}& \\frac{\\partial v}{\\partial T} \\end{bmatrix} \\begin{Bmatrix} dv_j \\\\ ds_j \\end{Bmatrix} \\] with all partial derivatives as a function of the guess vapor quality and temperature \\(f(x_j,T_j)\\) and \\[ \\begin{Bmatrix} dv_j \\\\ ds_j \\end{Bmatrix} = \\begin{Bmatrix} v_{i+1} - v(x_j,T_j) \\\\ s_{i+1} - s(x_j,T_j) \\\\ \\end{Bmatrix} \\] Ready for next step \u00b6 Once the quantities for \\(T_{i+1}\\) and \\(x_{i+1}\\) are estimated, the new value for pressure \\(p_i\\) and mass flow \\(\\dot{m}_i\\) are: \\[ \\begin{aligned} p_{i+1} &= p_{Sat} (T_{i+1}) \\\\ \\dot{m}_{i+1} &= \\frac{\\dot{m}_0}{p_0} \\cdot p_{i+1} \\\\ \\end{aligned} \\] The last equation assumes that the mass flow ratio and pressure is constant along the entire extraction. Loop Termination \u00b6 The extraction is over once the vapor quality \\(x\\) reaches the value of \\(1\\) , which is when the tank contains only vapor and the system is not biphasic anymore.","title":"Biphase Model for Saturated Tank"},{"location":"propulsion/tank/tank-biphase/#biphase-model-for-saturated-tank","text":"Alberto The tank holds a self pressurized oxidizer, which is in saturation condition between liquid and vapor.","title":"Biphase Model for Saturated Tank"},{"location":"propulsion/tank/tank-biphase/#oxidizer-extraction-model","text":"Suppose a tank is filled up to a certain point with liquid oxidizer and its vapor is saturated at a certain ambient temperature.","title":"Oxidizer Extraction Model"},{"location":"propulsion/tank/tank-biphase/#parameters","text":"The parameters of the tank before the extraction are: \\(V_T\\) Internal volume of the tank \\(m_O\\) Mass of oxidizer stored in the tank \\(T_0\\) Initial extraction temperature Other variables can thus be described, such as: \\(V_O\\) Volume occupied by liquid oxidizer \\(f\\) Ullage volume percentage The following solver needs as initial conditions only: \\(T_0\\) Starting saturation temperature \\(f\\) Vapor volume percentage (ullage) and the following data for the chosen oxidizer.","title":"Parameters"},{"location":"propulsion/tank/tank-biphase/#oxidizer-data","text":"Data for known properties of the oxidizer as a function of temperature are needed: \\(p_{Sat}(T)\\) Saturation pressure for a given temperature \\(\\rho_l(T)\\) Density of the saturated liquid for a given temperature \\(\\rho_v(T)\\) Density of the saturated vapor for a given temperature \\(s_l(T)\\) Specific entropy of the saturated liquid for a given temperature \\(s_v(T)\\) Specific entropy of the saturated vapor for a given temperature","title":"Oxidizer Data"},{"location":"propulsion/tank/tank-biphase/#extraction","text":"The physical quantities are regulated by the following expressions: \\[ \\begin{aligned} v_l(T) &= \\frac1{\\rho_l(T)} \\\\ v_v(T) &= \\frac1{\\rho_l(T)} \\\\ x(v, T) &= \\frac{v - v_l(T)}{v_v(T) - v_l(T)} \\\\ \\end{aligned} \\] The mapping of \\((x,T) \\to (s,v)\\) is given by: \\[ \\begin{aligned} s(x, T) &= (1 - x) \\cdot s_l(T) + x \\cdot s_v(T) \\\\ v(x, T) &= (1 - x) \\cdot v_l(T) + x \\cdot v_v(T) \\\\ \\end{aligned} \\] The goal is to find the inverse map \\[ (s,v) \\to (x,T) \\] since evaluating \\(s\\) and \\(v\\) for the mass extraction is trivial. The functions \\(s(x,T)\\) and \\(v(x,T)\\) can be differentiated with respect to \\(x\\) and \\(T\\) as: \\[ \\begin{aligned} dv = \\frac{\\partial v}{\\partial x}\\, dx + \\frac{\\partial v}{\\partial T}\\,dT \\\\ ds = \\frac{\\partial s}{\\partial x}\\, dx + \\frac{\\partial s}{\\partial T}\\,dT \\end{aligned} \\] which in matrix form becomes \\[ \\begin{Bmatrix} dv \\\\ ds \\end{Bmatrix} = \\begin{bmatrix} \\dfrac{\\partial v}{\\partial x} & \\dfrac{\\partial v}{\\partial T}\\\\ \\dfrac{\\partial s}{\\partial x}& \\dfrac{\\partial s}{\\partial T} \\end{bmatrix} \\begin{Bmatrix} dx \\\\ dT \\end{Bmatrix} \\] and inverting algebraically \\[ \\begin{Bmatrix} dx \\\\ dT \\end{Bmatrix} = \\begin{bmatrix} \\dfrac{\\partial v}{\\partial x} & \\dfrac{\\partial v}{\\partial T}\\\\ \\dfrac{\\partial s}{\\partial x}& \\dfrac{\\partial s}{\\partial T} \\end{bmatrix}^{-1} \\begin{Bmatrix} dv \\\\ ds \\end{Bmatrix} \\] The quantities sought after are then computed as: \\[ \\begin{Bmatrix} x(s,v) \\\\ T(s,v) \\end{Bmatrix} = \\begin{Bmatrix} x_0 \\\\ T_0 \\end{Bmatrix} + \\int_{(s_0,T_0)} [J]^{-1} \\begin{Bmatrix} dv \\\\ ds \\end{Bmatrix},\\quad \\text{until $x =1$} \\]","title":"Extraction"},{"location":"propulsion/tank/tank-biphase/#numerical-solution","text":"","title":"Numerical solution"},{"location":"propulsion/tank/tank-biphase/#time-constraints","text":"The extraction time \\(t_n\\) can be considered adimensional \\[ t_n = 1\\] therefore the \\(n\\) computation steps are \\[n = \\frac{t_n}{\\Delta t}\\] where \\(\\Delta t\\) is a reasonably low number (ex. \\(\\Delta t = 5\\cdot10^{-4}\\) ). Although the initial conditions are useful, some of them can be discarded by considering the problem adimensionalized with respect to the mass of oxidizer stored inside the tank.","title":"Time constraints"},{"location":"propulsion/tank/tank-biphase/#initial-conditions","text":"\\[ m_0 = 1 \\] Therefore the liquid mass is \\[ m_{l,0} = \\frac{m_0}{1 + f \\cdot \\frac{\\rho_{v,0}}{\\rho_{l,0}}} \\] And vapor mass is \\[ m_{v,0} = m_0 - m_{l,0}\\] The oxidizer liquid volume is simply \\[ V_{l,0} = \\frac{m_{l,0}}{\\rho_{l,0}} \\] which can be used to get the total volume \\[ V_0 = V_{l,0} \\cdot (1+f) \\] and the vapor volume \\[ V_{v,0} = V_0 - V_{l,0}.\\] The following are the initial conditions of the loop \\[ \\begin{aligned} T_0 &\\\\ p_0 &= p_{Sat}(T_0)\\\\ v_0 &= \\frac{V_0}{m_0} \\\\ x_0 &= x(v_0,T_0) \\\\ s_0 &= s(x_0, T_0) \\\\ S_0 &= m_0 \\cdot s_0 \\\\ \\dot{m}_0 &= \\frac{m_0}{t_n} \\end{aligned} \\]","title":"Initial conditions"},{"location":"propulsion/tank/tank-biphase/#mass-extraction","text":"The mass that gets extracted at every computation step from the tank is computed as \\[ dm_i = \\dot{m}_i \\cdot dt \\] and the remaining mass inside the tank is thus: \\[ m_{i+1} = m_i - dm_i \\] Whether the extraction is done of liquid oxidizer or vapor oxidizer, the entropy \\(S\\) of the mass left in the tank is computed as: \\[ \\begin{cases} S_{i+1} = S_i - dm_i \\cdot s_l(T_i),& \\quad \\text{liquid extraction}\\\\ S_{i+1} = S_i - dm_i \\cdot s_v(T_i),& \\quad \\text{vapor extraction} \\end{cases} \\] And thus the specific entropy \\(s\\) and specific volume \\(v\\) are \\[ \\begin{aligned} s_{i+1} &= \\frac{S_{i+1}}{m_{i+1}} \\\\ v_{i+1} &= \\frac{V_0}{m_{i+1}} \\end{aligned} \\]","title":"Mass extraction"},{"location":"propulsion/tank/tank-biphase/#vapor-quality-and-temperature-evaluation","text":"The next goal is to compute the variation of vapor quality \\(x\\) and temperature \\(T\\) given the variation in specific volume \\(v\\) and specific enthalpy \\(s\\) after th extraction. The problem is now finding the quantities inside the Jacobian matrix. The partial derivatives with respect to vapor quality \\(x\\) are immediate: \\[ \\begin{aligned} \\frac{\\partial v}{\\partial x} &= v_v(T) - v_l(T) \\\\ \\frac{\\partial s}{\\partial x} &= s_v(T) - s_l(T) \\end{aligned} \\] but the derivatives with respect to temperature \\(T\\) must be computed numerically, in this case with central finite difference: \\[ \\begin{aligned} \\frac{\\partial v}{\\partial T} &= \\frac1{2\\varepsilon} [v(x,T+\\varepsilon)-v(x,T-\\varepsilon)] \\\\ \\frac{\\partial s}{\\partial T} &= \\frac1{2\\varepsilon} [s(x,T+\\varepsilon)-s(x,T-\\varepsilon)] \\end{aligned} \\] Starting the evaluation from the current temperature \\(T_i\\) , the target temperature \\(T_{i+1}\\) will be reached with successive approssimation of a progressively changing temperature \\(T_j\\) until the residue \\(r\\) is under the desired tolerance: \\[ r = \\sqrt{\\frac{dT_j}{T_j}^2+\\frac{dx_j}{x_j}^2}\\leq \\text{tol} \\] The guesses for temperature \\(T_j\\) and vapor quality \\(x_j\\) are updated as: \\[ \\begin{aligned} T_{j+1} = T_j + dT_j \\\\ x_{j+1} = x_j + dx_j \\end{aligned} \\] until the final temperature \\(T_{i+1}\\) is the \\(n\\) -th guess temperature \\(T_j\\mid_{j=n}\\) . In summary: \\[ \\begin{aligned} T_{i+1} - T_{i} = \\sum_{\\substack{T_j=T_i \\\\ x_j = x_i}}^{r<tol} dT_j(x_j,T_j) \\\\ x_{i+1} - x_{i} = \\sum_{\\substack{T_j=T_i \\\\ x_j = x_i}}^{r<tol} dx_j(x_j,T_j) \\end{aligned} \\] where, using the formula for the inverse of a \\(2 \\times 2\\) matrix: \\[ \\begin{Bmatrix} dx_j \\\\ dT_j \\end{Bmatrix} = \\frac{1}{\\frac{\\partial v}{\\partial x}\\frac{\\partial s}{\\partial T} - \\frac{\\partial s}{\\partial x}\\frac{\\partial v}{\\partial T}} \\begin{bmatrix} \\frac{\\partial s}{\\partial x} & -\\frac{\\partial v}{\\partial T}\\\\ -\\frac{\\partial s}{\\partial x}& \\frac{\\partial v}{\\partial T} \\end{bmatrix} \\begin{Bmatrix} dv_j \\\\ ds_j \\end{Bmatrix} \\] with all partial derivatives as a function of the guess vapor quality and temperature \\(f(x_j,T_j)\\) and \\[ \\begin{Bmatrix} dv_j \\\\ ds_j \\end{Bmatrix} = \\begin{Bmatrix} v_{i+1} - v(x_j,T_j) \\\\ s_{i+1} - s(x_j,T_j) \\\\ \\end{Bmatrix} \\]","title":"Vapor Quality and Temperature Evaluation"},{"location":"propulsion/tank/tank-biphase/#ready-for-next-step","text":"Once the quantities for \\(T_{i+1}\\) and \\(x_{i+1}\\) are estimated, the new value for pressure \\(p_i\\) and mass flow \\(\\dot{m}_i\\) are: \\[ \\begin{aligned} p_{i+1} &= p_{Sat} (T_{i+1}) \\\\ \\dot{m}_{i+1} &= \\frac{\\dot{m}_0}{p_0} \\cdot p_{i+1} \\\\ \\end{aligned} \\] The last equation assumes that the mass flow ratio and pressure is constant along the entire extraction.","title":"Ready for next step"},{"location":"propulsion/tank/tank-biphase/#loop-termination","text":"The extraction is over once the vapor quality \\(x\\) reaches the value of \\(1\\) , which is when the tank contains only vapor and the system is not biphasic anymore.","title":"Loop Termination"},{"location":"software/cae/","text":"Computer Aided Engineering \u00b6 This page is a list of software used or considered for the development of the project components. Open Source or Free \u00b6 Git Python OpenFoam PrePomax Calculix FreeCAD Moose Code-Aster and Salome-meca Gmsh yEd KiCad LaTeX Licensed \u00b6 MATLAB SolidWorks Inventor ANSYS Patran/Nastran AutoCAD Microsoft Office Visio","title":"Computer Aided Engineering"},{"location":"software/cae/#computer-aided-engineering","text":"This page is a list of software used or considered for the development of the project components.","title":"Computer Aided Engineering"},{"location":"software/cae/#open-source-or-free","text":"Git Python OpenFoam PrePomax Calculix FreeCAD Moose Code-Aster and Salome-meca Gmsh yEd KiCad LaTeX","title":"Open Source or Free"},{"location":"software/cae/#licensed","text":"MATLAB SolidWorks Inventor ANSYS Patran/Nastran AutoCAD Microsoft Office Visio","title":"Licensed"},{"location":"software/magnet/","text":"Magnet \u00b6 This document explains how to download a file from a magnet: link. In order to download publicly distributed files through the P2P technology like Debian Server ISO, the most direct way is to use a magnet: link. Requirements \u00b6 An installed bittorrent client like: qBitTorrent , choco install qbittorrent -y , installed client Deluge , choco install deluge -y , installed client \u03b2Torrent , web based client A magnet: link to download Downloading \u00b6 On the top left of the user interface, there will be a magnet U icon or a link 8 icon with a + sign. Copy the magnet: link; Click the \"Add torrent from magnet link\"; Paste the magnet: link in the popup; Select download location and wait until the download is completed.","title":"Magnet"},{"location":"software/magnet/#magnet","text":"This document explains how to download a file from a magnet: link. In order to download publicly distributed files through the P2P technology like Debian Server ISO, the most direct way is to use a magnet: link.","title":"Magnet"},{"location":"software/magnet/#requirements","text":"An installed bittorrent client like: qBitTorrent , choco install qbittorrent -y , installed client Deluge , choco install deluge -y , installed client \u03b2Torrent , web based client A magnet: link to download","title":"Requirements"},{"location":"software/magnet/#downloading","text":"On the top left of the user interface, there will be a magnet U icon or a link 8 icon with a + sign. Copy the magnet: link; Click the \"Add torrent from magnet link\"; Paste the magnet: link in the popup; Select download location and wait until the download is completed.","title":"Downloading"}]}